Metadata-Version: 2.4
Name: semantica-task-sdk
Version: 0.1.0
Summary: Python SDK for SemanticaTask Engine
Author: Semantica Team
License: MIT
Project-URL: Homepage, https://github.com/your-org/semantica-task-engine
Project-URL: Repository, https://github.com/your-org/semantica-task-engine
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Requires-Dist: httpx>=0.24.0
Provides-Extra: dev
Requires-Dist: pytest>=7.0; extra == "dev"
Requires-Dist: pytest-asyncio>=0.21.0; extra == "dev"
Requires-Dist: pytest-cov>=4.0; extra == "dev"
Requires-Dist: black>=23.0; extra == "dev"
Requires-Dist: ruff>=0.1.0; extra == "dev"

# SemanticaTask Python SDK

**ë¹„ë™ê¸° Job Queue ì‹œìŠ¤í…œìš© Python í´ë¼ì´ì–¸íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬**

> AI/LLMì´ ì´ ë¬¸ì„œë¥¼ ì½ê³  SDKë¥¼ ìë™ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì‘ì„±ë¨.

---

## ğŸ¯ ëª©ì 

SemanticaTask Engineì€ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰ë˜ëŠ” Job Queue ì‹œìŠ¤í…œì„.  
ì´ SDKëŠ” Pythonì—ì„œ JSON-RPC 2.0ìœ¼ë¡œ Jobì„ ë“±ë¡/ì·¨ì†Œ/ì¡°íšŒí•˜ëŠ” í´ë¼ì´ì–¸íŠ¸ì„.

---

## ğŸ“¦ ì„¤ì¹˜

```bash
# PyPI (ì¤€ë¹„ ì¤‘)
pip install semantica-task-sdk

# Gitì—ì„œ ì§ì ‘ ì„¤ì¹˜
pip install git+https://github.com/your-org/semantica-task-engine#subdirectory=python-sdk

# ë¡œì»¬ ê°œë°œ
cd python-sdk
pip install -e .
```

**ì˜ì¡´ì„±**: `httpx>=0.24.0` (ë¹„ë™ê¸° HTTP í´ë¼ì´ì–¸íŠ¸)

---

## ğŸš€ ë¹ ë¥¸ ì‹œì‘ (5ë¶„)

### 1. Daemon ì‹¤í–‰ (í•„ìˆ˜)

```bash
# Rust í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ
cargo run --package semantica-daemon

# ë˜ëŠ” Docker
docker run -p 9527:9527 semantica-task-engine
```

í¬íŠ¸: ê¸°ë³¸ê°’ `9527`, í™˜ê²½ë³€ìˆ˜ `SEMANTICA_RPC_PORT`ë¡œ ë³€ê²½ ê°€ëŠ¥.

### 2. Python ì½”ë“œì—ì„œ ì‚¬ìš©

```python
import asyncio
from semantica import SemanticaTaskClient, EnqueueRequest

async def main():
    # 1. Daemonì— ì—°ê²° (async with í•„ìˆ˜)
    async with SemanticaTaskClient("http://127.0.0.1:9527") as client:
        
        # 2. Job ë“±ë¡
        response = await client.enqueue(
            EnqueueRequest(
                job_type="INDEX_FILE",          # Job íƒ€ì… (ë¬¸ìì—´)
                queue="default",                # í ì´ë¦„
                subject_key="src/main.py",      # Subject key (ì¤‘ë³µ ë°©ì§€ìš©)
                payload={"path": "src/main.py"},  # JSON ì§ë ¬í™” ê°€ëŠ¥í•œ ë°ì´í„°
                priority=5,                     # ìš°ì„ ìˆœìœ„ (ë†’ì„ìˆ˜ë¡ ë¨¼ì € ì‹¤í–‰)
            )
        )
        
        print(f"âœ… Job ë“±ë¡ë¨: {response.job_id}")
        print(f"   ìƒíƒœ: {response.state}")
        print(f"   í: {response.queue}")
        
        # 3. ë¡œê·¸ ì¡°íšŒ
        logs = await client.tail_logs(response.job_id, lines=100)
        for line in logs.lines:
            print(f"   [LOG] {line}")
        
        # 4. Job ì·¨ì†Œ
        cancel_resp = await client.cancel(response.job_id)
        if cancel_resp.cancelled:
            print("âœ… Job ì·¨ì†Œë¨")

asyncio.run(main())
```

---

## ğŸ“– API ë ˆí¼ëŸ°ìŠ¤

### `SemanticaTaskClient`

#### ìƒì„±ì

```python
SemanticaTaskClient(
    url: str = "http://127.0.0.1:9527",
    timeout: float = 30.0
)
```

**íŒŒë¼ë¯¸í„°**:
- `url` (str): Daemon RPC ì—”ë“œí¬ì¸íŠ¸. ê¸°ë³¸ê°’ `http://127.0.0.1:9527`
- `timeout` (float): HTTP ìš”ì²­ íƒ€ì„ì•„ì›ƒ (ì´ˆ). ê¸°ë³¸ê°’ `30.0`

**ì‚¬ìš©ë²•**: `async with` ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €ë¡œ ì‚¬ìš© (í•„ìˆ˜!)

```python
async with SemanticaTaskClient("http://localhost:7701") as client:
    # client ì‚¬ìš©
    pass
```

---

### ë©”ì„œë“œ: `enqueue()`

Jobì„ íì— ë“±ë¡í•¨.

```python
await client.enqueue(request: EnqueueRequest) -> EnqueueResponse
```

#### ì…ë ¥: `EnqueueRequest`

| í•„ë“œ | íƒ€ì… | í•„ìˆ˜ | ì„¤ëª… | ì˜ˆì‹œ |
|------|------|------|------|------|
| `job_type` | `str` | âœ… | Job íƒ€ì… ì‹ë³„ì | `"INDEX_FILE"`, `"ANALYZE_CODE"` |
| `queue` | `str` | âœ… | í ì´ë¦„ | `"default"`, `"code_intel"` |
| `subject_key` | `str` | âœ… | Subject key (ì¤‘ë³µ ë°©ì§€) | `"repo123::src/main.py"` |
| `payload` | `Any` | âœ… | Job ë°ì´í„° (JSON ì§ë ¬í™” ê°€ëŠ¥) | `{"path": "src/main.py", "mode": "full"}` |
| `priority` | `int` | âŒ | ìš°ì„ ìˆœìœ„ (ê¸°ë³¸ê°’: 0) | `0`, `5`, `-10` |

**Subject Key ê·œì¹™**:
- ë™ì¼í•œ `subject_key`ë¥¼ ê°€ì§„ Jobì´ QUEUED ìƒíƒœë¡œ ìˆìœ¼ë©´ ê¸°ì¡´ Jobì„ SUPERSEDEDë¡œ ë³€ê²½í•˜ê³  ìƒˆ Jobì„ ë“±ë¡í•¨ (ìµœì‹  ê²ƒë§Œ ì‹¤í–‰).
- íŒŒì¼ ê²½ë¡œ, ì‚¬ìš©ì ID ë“± ê³ ìœ  ì‹ë³„ìë¥¼ ì‚¬ìš©.

#### ì¶œë ¥: `EnqueueResponse`

| í•„ë“œ | íƒ€ì… | ì„¤ëª… | ì˜ˆì‹œ |
|------|------|------|------|
| `job_id` | `str` | Job UUID | `"c4b2bb3a-72f0-4f1e-8f6b-3aa95b2e18c3"` |
| `state` | `str` | Job ìƒíƒœ | `"QUEUED"`, `"RUNNING"`, `"DONE"`, `"FAILED"` |
| `queue` | `str` | í ì´ë¦„ | `"default"` |

#### ì˜ˆì œ

```python
response = await client.enqueue(
    EnqueueRequest(
        job_type="INDEX_FILE",
        queue="default",
        subject_key="project-1::src/main.py",
        payload={
            "repo_id": "project-1",
            "path": "src/main.py",
            "language": "python"
        },
        priority=10,
    )
)

print(response.job_id)  # "c4b2bb3a-..."
print(response.state)   # "QUEUED"
```

---

### ë©”ì„œë“œ: `cancel()`

Jobì„ ì·¨ì†Œí•¨ (QUEUED ë˜ëŠ” RUNNING ìƒíƒœë§Œ ì·¨ì†Œ ê°€ëŠ¥).

```python
await client.cancel(job_id: str) -> CancelResponse
```

#### ì…ë ¥

| íŒŒë¼ë¯¸í„° | íƒ€ì… | í•„ìˆ˜ | ì„¤ëª… |
|---------|------|------|------|
| `job_id` | `str` | âœ… | Job UUID |

#### ì¶œë ¥: `CancelResponse`

| í•„ë“œ | íƒ€ì… | ì„¤ëª… |
|------|------|------|
| `job_id` | `str` | Job UUID |
| `cancelled` | `bool` | ì·¨ì†Œ ì„±ê³µ ì—¬ë¶€ (`True`: ì·¨ì†Œë¨, `False`: ì´ë¯¸ ì™„ë£Œë¨) |

#### ì˜ˆì œ

```python
response = await client.cancel("c4b2bb3a-72f0-4f1e-8f6b-3aa95b2e18c3")

if response.cancelled:
    print("âœ… Job ì·¨ì†Œë¨")
else:
    print("âš ï¸ Jobì´ ì´ë¯¸ ì™„ë£Œë˜ì–´ ì·¨ì†Œ ë¶ˆê°€")
```

---

### ë©”ì„œë“œ: `tail_logs()`

Job ì‹¤í–‰ ë¡œê·¸ë¥¼ ì¡°íšŒí•¨.

```python
await client.tail_logs(job_id: str, lines: int = 50) -> TailLogsResponse
```

#### ì…ë ¥

| íŒŒë¼ë¯¸í„° | íƒ€ì… | í•„ìˆ˜ | ê¸°ë³¸ê°’ | ì„¤ëª… |
|---------|------|------|--------|------|
| `job_id` | `str` | âœ… | - | Job UUID |
| `lines` | `int` | âŒ | `50` | ì¡°íšŒí•  ë¡œê·¸ ë¼ì¸ ìˆ˜ (ìµœëŒ€ 1000) |

#### ì¶œë ¥: `TailLogsResponse`

| í•„ë“œ | íƒ€ì… | ì„¤ëª… |
|------|------|------|
| `job_id` | `str` | Job UUID |
| `log_path` | `Optional[str]` | ë¡œê·¸ íŒŒì¼ ê²½ë¡œ (ì—†ìœ¼ë©´ `None`) |
| `lines` | `list[str]` | ë¡œê·¸ ë¼ì¸ ë°°ì—´ (ìµœì‹ ìˆœ) |

#### ì˜ˆì œ

```python
response = await client.tail_logs("c4b2bb3a-...", lines=100)

print(f"ë¡œê·¸ íŒŒì¼: {response.log_path}")
print(f"ë¼ì¸ ìˆ˜: {len(response.lines)}")

for line in response.lines:
    print(line)
```

---

## ğŸ”¥ ì‹¤ì „ ì‚¬ìš© ì˜ˆì œ

### ì˜ˆì œ 1: íŒŒì¼ ì¸ë±ì‹± Job

```python
import asyncio
from semantica import SemanticaTaskClient, EnqueueRequest

async def index_files(file_paths: list[str]):
    async with SemanticaTaskClient("http://localhost:9527") as client:
        job_ids = []
        
        for path in file_paths:
            response = await client.enqueue(
                EnqueueRequest(
                    job_type="INDEX_FILE",
                    queue="code_intel",
                    subject_key=f"repo-1::{path}",  # ì¤‘ë³µ ë°©ì§€
                    payload={
                        "repo_id": "repo-1",
                        "path": path,
                        "action": "full_index"
                    },
                    priority=5 if path.endswith(".py") else 0,  # Python ìš°ì„ 
                )
            )
            job_ids.append(response.job_id)
            print(f"âœ… {path} -> {response.job_id}")
        
        return job_ids

# ì‚¬ìš©
asyncio.run(index_files([
    "src/main.py",
    "src/utils.py",
    "tests/test_main.py"
]))
```

### ì˜ˆì œ 2: Job ìƒíƒœ ëª¨ë‹ˆí„°ë§

```python
import asyncio
from semantica import SemanticaTaskClient, EnqueueRequest

async def monitor_job(job_id: str):
    """Jobì´ ì™„ë£Œë  ë•Œê¹Œì§€ ë¡œê·¸ í´ë§"""
    async with SemanticaTaskClient() as client:
        while True:
            logs = await client.tail_logs(job_id, lines=10)
            
            # ë¡œê·¸ ì¶œë ¥
            for line in logs.lines:
                print(f"[{job_id[:8]}] {line}")
            
            # ì™„ë£Œ ì²´í¬ (ë¡œê·¸ì— "DONE" ë˜ëŠ” "FAILED" í¬í•¨ ì‹œ ì¢…ë£Œ)
            if any("DONE" in line or "FAILED" in line for line in logs.lines):
                print(f"âœ… Job {job_id} ì™„ë£Œ")
                break
            
            await asyncio.sleep(2)  # 2ì´ˆë§ˆë‹¤ í´ë§

# ì‚¬ìš©
asyncio.run(monitor_job("c4b2bb3a-..."))
```

### ì˜ˆì œ 3: ì—ëŸ¬ ì²˜ë¦¬

```python
import asyncio
from semantica import (
    SemanticaTaskClient,
    EnqueueRequest,
    ConnectionError,
    RpcError,
)

async def safe_enqueue():
    try:
        async with SemanticaTaskClient("http://localhost:9527") as client:
            response = await client.enqueue(
                EnqueueRequest(
                    job_type="INDEX_FILE",
                    queue="default",
                    subject_key="test.py",
                    payload={"path": "test.py"},
                )
            )
            print(f"âœ… Job: {response.job_id}")
    
    except ConnectionError as e:
        print(f"âŒ ì—°ê²° ì‹¤íŒ¨: {e.message}")
        print("   Daemonì´ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.")
    
    except RpcError as e:
        print(f"âŒ RPC ì—ëŸ¬ (ì½”ë“œ {e.code}): {e.message}")
        if e.code == 4001:
            print("   ì˜ëª»ëœ ìš”ì²­ íŒŒë¼ë¯¸í„°ì…ë‹ˆë‹¤.")
        elif e.code >= 5000:
            print("   ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ì…ë‹ˆë‹¤.")
    
    except Exception as e:
        print(f"âŒ ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬: {e}")

asyncio.run(safe_enqueue())
```

### ì˜ˆì œ 4: í™˜ê²½ë³€ìˆ˜ë¡œ URL ì„¤ì •

```python
import os
import asyncio
from semantica import SemanticaTaskClient, EnqueueRequest

async def main():
    # í™˜ê²½ë³€ìˆ˜ SEMANTICA_RPC_URL ì‚¬ìš© (ê¸°ë³¸ê°’: http://127.0.0.1:9527)
    url = os.getenv("SEMANTICA_RPC_URL", "http://127.0.0.1:9527")
    
    async with SemanticaTaskClient(url) as client:
        response = await client.enqueue(
            EnqueueRequest(
                job_type="TEST",
                queue="default",
                subject_key="test",
                payload={}
            )
        )
        print(f"Job: {response.job_id}")

asyncio.run(main())
```

```bash
# í™˜ê²½ë³€ìˆ˜ ì„¤ì •
export SEMANTICA_RPC_URL=http://localhost:7701

# ì‹¤í–‰
python my_script.py
```

---

## ğŸ›¡ï¸ ì—ëŸ¬ ì²˜ë¦¬

### ì—ëŸ¬ ê³„ì¸µ êµ¬ì¡°

```
SemanticaTaskError (ë² ì´ìŠ¤)
â”œâ”€â”€ ConnectionError    # HTTP ì—°ê²° ì‹¤íŒ¨, íƒ€ì„ì•„ì›ƒ
â””â”€â”€ RpcError           # JSON-RPC ì—ëŸ¬ (ì„œë²„ì—ì„œ ë°˜í™˜)
```

### `ConnectionError`

**ë°œìƒ ì¡°ê±´**:
- Daemonì´ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹˜
- ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì‹¤íŒ¨
- íƒ€ì„ì•„ì›ƒ (ê¸°ë³¸ 30ì´ˆ)

**ì†ì„±**:
- `message` (str): ì—ëŸ¬ ë©”ì‹œì§€

**ì²˜ë¦¬**:
```python
except ConnectionError as e:
    print(f"ì—°ê²° ì‹¤íŒ¨: {e.message}")
    # Daemon ì¬ì‹œì‘ ë˜ëŠ” URL í™•ì¸
```

### `RpcError`

**ë°œìƒ ì¡°ê±´**:
- ì˜ëª»ëœ íŒŒë¼ë¯¸í„° (4xxx ì—ëŸ¬ ì½”ë“œ)
- ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ (5xxx ì—ëŸ¬ ì½”ë“œ)

**ì†ì„±**:
- `code` (int): ì—ëŸ¬ ì½”ë“œ (JSON-RPC í‘œì¤€)
- `message` (str): ì—ëŸ¬ ë©”ì‹œì§€
- `data` (Optional[Any]): ì¶”ê°€ ë°ì´í„°

**ì—ëŸ¬ ì½”ë“œ**:
| ì½”ë“œ ë²”ìœ„ | ì˜ë¯¸ | ì˜ˆì‹œ |
|----------|------|------|
| 4000-4999 | í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ | `4001`: ì˜ëª»ëœ íŒŒë¼ë¯¸í„° |
| 5000-5999 | ì„œë²„ ì—ëŸ¬ | `5000`: ë‚´ë¶€ ì˜¤ë¥˜, `5001`: DB ì—ëŸ¬ |

**ì²˜ë¦¬**:
```python
except RpcError as e:
    if 4000 <= e.code < 5000:
        print(f"í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ ({e.code}): {e.message}")
        # íŒŒë¼ë¯¸í„° ìˆ˜ì • í•„ìš”
    elif 5000 <= e.code < 6000:
        print(f"ì„œë²„ ì—ëŸ¬ ({e.code}): {e.message}")
        # ì¬ì‹œë„ ë˜ëŠ” ê´€ë¦¬ì ë¬¸ì˜
```

---

## ğŸ”§ ê³ ê¸‰ ì‚¬ìš©ë²•

### íƒ€ì„ì•„ì›ƒ ì„¤ì •

```python
# ì§§ì€ íƒ€ì„ì•„ì›ƒ (ë¹ ë¥¸ ì‹¤íŒ¨)
async with SemanticaTaskClient(timeout=5.0) as client:
    response = await client.enqueue(...)

# ê¸´ íƒ€ì„ì•„ì›ƒ (ëŒ€ìš©ëŸ‰ Job)
async with SemanticaTaskClient(timeout=120.0) as client:
    response = await client.enqueue(...)
```

### ë³‘ë ¬ Job ë“±ë¡

```python
import asyncio
from semantica import SemanticaTaskClient, EnqueueRequest

async def enqueue_parallel(files: list[str]):
    async with SemanticaTaskClient() as client:
        tasks = [
            client.enqueue(
                EnqueueRequest(
                    job_type="INDEX_FILE",
                    queue="default",
                    subject_key=f"file::{file}",
                    payload={"path": file},
                )
            )
            for file in files
        ]
        
        # ëª¨ë‘ ë³‘ë ¬ ì‹¤í–‰
        responses = await asyncio.gather(*tasks)
        
        for response in responses:
            print(f"âœ… {response.job_id}")

asyncio.run(enqueue_parallel(["file1.py", "file2.py", "file3.py"]))
```

### ì¬ì‹œë„ ë¡œì§

```python
import asyncio
from semantica import SemanticaTaskClient, EnqueueRequest, RpcError

async def enqueue_with_retry(request: EnqueueRequest, max_retries: int = 3):
    async with SemanticaTaskClient() as client:
        for attempt in range(max_retries):
            try:
                response = await client.enqueue(request)
                return response
            except RpcError as e:
                if e.code >= 5000 and attempt < max_retries - 1:
                    wait_time = 2 ** attempt  # ì§€ìˆ˜ ë°±ì˜¤í”„
                    print(f"âš ï¸ ì¬ì‹œë„ {attempt + 1}/{max_retries} ({wait_time}ì´ˆ ëŒ€ê¸°)")
                    await asyncio.sleep(wait_time)
                else:
                    raise

# ì‚¬ìš©
response = await enqueue_with_retry(
    EnqueueRequest(
        job_type="INDEX_FILE",
        queue="default",
        subject_key="test.py",
        payload={"path": "test.py"}
    )
)
```

---

## ğŸ§ª í…ŒìŠ¤íŠ¸

```bash
# ê°œë°œ ì˜ì¡´ì„± ì„¤ì¹˜
pip install -e ".[dev]"

# í…ŒìŠ¤íŠ¸ ì‹¤í–‰
pytest

# ì»¤ë²„ë¦¬ì§€ í™•ì¸
pytest --cov=semantica --cov-report=html
open htmlcov/index.html

# ì½”ë“œ í¬ë§·íŒ…
black semantica tests

# Lint ê²€ì‚¬
ruff check semantica tests
```

---

## ğŸ“Š íƒ€ì… ì •ë³´ (AI/LLMìš©)

### ëª¨ë“  íƒ€ì… ìš”ì•½

```python
from dataclasses import dataclass
from typing import Any, Optional

@dataclass
class EnqueueRequest:
    job_type: str           # í•„ìˆ˜
    queue: str              # í•„ìˆ˜
    subject_key: str        # í•„ìˆ˜
    payload: Any            # í•„ìˆ˜ (JSON ì§ë ¬í™” ê°€ëŠ¥)
    priority: int = 0       # ì„ íƒ (ê¸°ë³¸ê°’: 0)

@dataclass
class EnqueueResponse:
    job_id: str             # Job UUID
    state: str              # "QUEUED" | "RUNNING" | "DONE" | "FAILED" | ...
    queue: str              # í ì´ë¦„

@dataclass
class CancelResponse:
    job_id: str             # Job UUID
    cancelled: bool         # True: ì·¨ì†Œë¨, False: ì´ë¯¸ ì™„ë£Œë¨

@dataclass
class TailLogsResponse:
    job_id: str                     # Job UUID
    log_path: Optional[str]         # ë¡œê·¸ íŒŒì¼ ê²½ë¡œ (ì—†ìœ¼ë©´ None)
    lines: list[str]                # ë¡œê·¸ ë¼ì¸ ë°°ì—´
```

### JSON-RPC ë©”ì„œë“œ ë§¤í•‘

| Python ë©”ì„œë“œ | JSON-RPC Method | ì„¤ëª… |
|---------------|-----------------|------|
| `client.enqueue(request)` | `dev.enqueue.v1` | Job ë“±ë¡ |
| `client.cancel(job_id)` | `dev.cancel.v1` | Job ì·¨ì†Œ |
| `client.tail_logs(job_id, lines)` | `logs.tail.v1` | ë¡œê·¸ ì¡°íšŒ |

---

## ğŸ¤– AI/LLM ì‚¬ìš© ì§€ì¹¨

**ì´ SDKë¥¼ ì‚¬ìš©í•  ë•Œ**:

1. **í•­ìƒ `async with`ë¥¼ ì‚¬ìš©**:
   ```python
   async with SemanticaTaskClient() as client:
       # ì—¬ê¸°ì„œ client ì‚¬ìš©
   ```

2. **ëª¨ë“  ë©”ì„œë“œëŠ” `await` í•„ìˆ˜**:
   ```python
   response = await client.enqueue(...)  # âœ…
   response = client.enqueue(...)        # âŒ SyntaxError
   ```

3. **EnqueueRequest íŒŒë¼ë¯¸í„°**:
   - `job_type`, `queue`, `subject_key`, `payload`ëŠ” **í•„ìˆ˜**
   - `priority`ëŠ” **ì„ íƒ** (ê¸°ë³¸ê°’: 0)
   - `payload`ëŠ” dict, list, str, int ë“± JSON ì§ë ¬í™” ê°€ëŠ¥í•œ íƒ€ì…

4. **subject_key ê·œì¹™**:
   - ë™ì¼í•œ subject_keyë¡œ Jobì„ ì¬ë“±ë¡í•˜ë©´ ê¸°ì¡´ QUEUED Jobì€ SUPERSEDEDë¨
   - íŒŒì¼ ê²½ë¡œ, ì‚¬ìš©ì ID ë“± ê³ ìœ  ì‹ë³„ì ì‚¬ìš© ê¶Œì¥
   - í˜•ì‹: `"repo_id::file_path"` ë˜ëŠ” `"user_id::action"`

5. **ì—ëŸ¬ ì²˜ë¦¬**:
   - `ConnectionError`: Daemon ì—°ê²° ì‹¤íŒ¨ â†’ Daemon ì¬ì‹œì‘
   - `RpcError`: ì„œë²„ ì—ëŸ¬ â†’ ì½”ë“œ 4xxxëŠ” íŒŒë¼ë¯¸í„° ìˆ˜ì •, 5xxxëŠ” ì¬ì‹œë„

6. **ì‹¤í–‰ í™˜ê²½**:
   - Daemonì´ `http://127.0.0.1:9527`ì—ì„œ ì‹¤í–‰ ì¤‘ì´ì–´ì•¼ í•¨
   - ë‹¤ë¥¸ í¬íŠ¸ ì‚¬ìš© ì‹œ `SemanticaTaskClient(url="http://localhost:7701")`

---

## ğŸ“ ë¼ì´ì„ ìŠ¤

MIT

---

## ğŸ”— ê´€ë ¨ ë§í¬

- [SemanticaTask Engine (Rust)](../README.md)
- [API Specification](../docs/api-spec.md)
- [Daemon ì‚¬ìš©ë²•](../crates/daemon/README.md)

---

**ë²„ì „**: 0.1.0  
**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2025-12-05
